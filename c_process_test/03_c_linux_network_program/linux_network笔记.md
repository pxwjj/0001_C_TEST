1. **网络知识**

   1. 根据网络号 来判断是 abc三类网络。 0开头是a类（**0**000 0000-**0**111 1111），128开头 b类（1**0**00 0000-1**0**11 1111），192开头是c类（11**0**0 0000-11**0**1 1111）

   2. 网络号，主机号， IP地址 ，子网掩码 ，广播地址

   3. eg: 192.168.0.1/24

      1. 是一个c类网络，网络号是ip地址前24位，192.168.0.0 主机号是后八位 1-254
      2. 子网掩码 255.255.255.0
      3. 广播地址 192.168.0.255
      4. **地址和子网掩码做 与 操作 ，结果就是 网络号。ip地址和子网掩码取反的结果 做 与 操作，结果就是主机号。**

   4. 计算：16.158.165.91/22

      1. 子网掩码：255.255.252.0
      2. 网络号：16.158.164.0
      3. 这个网络的第一个地址：16.158.164.1
      4. 广播地址：16.158.167.255

   5. **DHCP协议**

      1. 新设备来了之后，发送广播信息，请求给分个ip
      2. 如果局域网中有 dhcp server ，那么给这个新设备 分一个ip地址。
      3. 新设备回复一下，接受的ip地址。
      4. server回复，可以。

   6. **OSI**(开放式系统互联通信参考模型)

      | 参考模型   | 各层解释                      | 对应设备                   | 典型协议                |
      | ---------- | ----------------------------- | -------------------------- | ----------------------- |
      | 应用层     | 未用用程序提供服务            | 计算机                     | DHCP、DNS               |
      | 表示层     | 数据格式转换、数据加密        | 计算机                     | Telnet、SNMP            |
      | 会话层     | 建立、管理、维护会话          | 计算机                     | SMTP、SSH               |
      | **传输层** | 建立、管理、维护 端到端的连接 | 进程和**端口**             | TCP、UDP                |
      | **网络层** | **IP**选址和路由选择          | 路由器、交换机、多层交换机 | **IP**、**ICMP**、ARP   |
      | 数据链路层 | 提供介质访问和链路管理        | 网卡，网桥，交换机         | PPP、Ethernet（以太网） |
      | 物理层     | 物理层                        | 中继器、集线器、网线       | IEEE 802.[1A,2..11]     |

      1. arp协议，知道ip查mac。 （ip相当于收货地址，mac相当于身份证）
      2. 传输层以上的协议，才有端口一说。所以ICMP没有端口。
      3. 路由器中有两张网卡（两个不同网段的ip）。一张连接到局域网（是一个局域网的网关ip）。一张连接的是万维网，用于，当前局域网中的设备进行上网（eg：访问百度服务器）

2. **linux 网络编程**

   1. 端口号范围 `0 - 2^16-1` 65535 ，16位

   2. UDP：不面向连接，不保证传输的可靠性

   3. | 源端口号（16位）2字节    | 目标端口号（16位）2字节    |
      | ------------------------ | -------------------------- |
      | **UDP长度（16位）2字节** | **UDP校验和（16位）2字节** |
      | 数据                     | 数据                       |

   4. TCP：

   5. |                                                              |                  |
      | ------------------------------------------------------------ | ---------------- |
      | 源端口号（16）                                               | 目标端口号（16） |
      | 序号（32）**解决乱序问题**                                   |                  |
      | 确认序号（32）ACK                                            |                  |
      | 首部长度（4位）保留位（6位）URG ACK PSH RST SYN FIN（各占一位） | 窗口大小（16位） |
      | 校验和（16）                                                 | 紧急指针（16）   |
      | 选项                                                         |                  |
      | 数据                                                         |                  |

      1. SYN ：发起一个连接
      2. ACK：回复
      3. RST：重新连接
      4. FIN：结束链接

   6. 为什么是三次握手，而不是两次或者四次

      1. A对B说：你好，我是A。
      2. B对A说：你好A，我是B，我可以听到。
      3. A对B说：你好B，我也可以听到。
      4. 此时连通建立成功。
      5. 如果只有两次，那么B不能确定A能不能收到B的消息。
      6. 如果有四次 就有点多余。

   7. 四次挥手

      1. A对B说：走吧，不玩了，撤
      2. B对A说：行。然后B处理一些操作。
      3. B对A说：走吧，没事了，撤
      4. A对B说：ok，走。

3. **套接字编程**

   1. 网络字节序 是大端
   2. honl(): 主机字节序，转成网络字节序
   3. `tcp_socket = socket(AF_INET, SOCK_STREAM, 0);`
   4. `udp_socket = socket(AF_INET, SOCK_DGRAM, 0);`
   5. server:
      1. `listenfd = socket()` , 返回一个套接字。
      2. `bind(listenfd, 服务器地址和端口)`, 将套接字，绑定到，设置的ip和端口上。
      3. `listen(listenfd, 连接队列长度)`, 开始监听,使listenfd成为一个监听描述符.
      4. `connfd = accept(listenfd, 客户端地址端口)`,阻塞等待客户端连接。返回用于读写数据给客户端的socket文件描述符（套接字).
      5. `read(connfd, buf, size);write(connfd, buf, size)`
      6. `close(connfd) `关闭
   6. client:
      1. `fd = socket();`分配一个套接字
      2. `connect(fd, 服务器地址端口);` 发送连接请求,阻塞等待服务器相应
      3. `read(fd, buf, size);write(fd, buf, size)`
      4. `close(fd);`
   7. 其他用到的函数：
      1. `inet_pton()`把点分十进制字符串，转成网络字节序（sockaddr_in结构体中的ip格式）。
      2. `inet_ntop()`把结构体中的内容转成，点分十进制的字符串。
      3.  `htons()`把主机字节序转成网络字节序（16位）
      4.  `htonl()`把主机字节序转成网络字节序（32位）
      5.  `ntohs()`把网络字节序转成主机字节序（16位）
      6.  `ntohs()`把网络字节序转成主机字节序（32位）
   8. `ESTABLISHED`这个状态 属于，客户端和服务端，已经建立连接。可以互相发送数据
